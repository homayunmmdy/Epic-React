# React Lifecycle

The React lifecycle begins with the **initial render**, where the component is first rendered to the DOM. During this phase, React creates the **DOM elements** based on the component's structure and state.

When a **user interacts** with the application (e.g., clicking a button or typing in an input), the component's state may change. This triggers a **re-render**. Unlike a full page refresh, React efficiently updates only the parts of the UI that have changed. It achieves this by comparing the **old virtual DOM** with the **new virtual DOM** in a process called **reconciliation**. React then applies only the **necessary changes** to the real DOM, ensuring optimal performance.

After the update, React waits for the next **user interaction**, and the cycle repeats.

<img src="./images/react_app_lifecycle.png" alt="React lifecycle" />

# Query in React

In React, a "query" often refers to a search term or filter condition used to fetch or display specific data. When using `useState`, you can store this query as a state variable, allowing you to dynamically update and filter data based on user input. For example, if you have a list of items, you can use a query state to filter the list as the user types.

```jsx
import React, { useState } from "react";

function App() {
  const [query, setQuery] = useState("");
  const items = ["apple", "banana", "cherry"];

  const filteredItems = items.filter((item) => item.includes(query));

  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
      />
      <ul>
        {filteredItems.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
    </div>
  );
}

export default App;
```

In this example, `query` is the state variable that holds the filter condition, and `filteredItems` dynamically updates based on the query.

# controlled input

a controlled input is an input field whose value is managed by React state. When the user types, an onChange event updates the state, and the input's value is set from that state.

```javascript
import React, { useState } from "react";

function App() {
  const [text, setText] = useState(""); // State to hold input value

  return (
    <div>
      <input
        type="text"
        value={text} // Input value is controlled by state
        onChange={(e) => setText(e.target.value)} // Update state on change
      />
      <p>You typed: {text}</p>
    </div>
  );
}

export default App;
```


### **Why Use Controlled Inputs?**
1. **Single Source of Truth**: The input's value is stored in React state, making it easy to access and manipulate.
2. **Real-time Validation**: You can validate or transform user input as they type.
3. **Dynamic Behavior**: You can conditionally update the UI based on the input value.
4. **Form Submission**: Easily gather all form data from the state when submitting.

### **When to Use Controlled Inputs?**
- When you need to **control or validate user input** dynamically.
- When you want to **synchronize input values** with other parts of the UI.
- When building forms that require **real-time updates** or complex logic.