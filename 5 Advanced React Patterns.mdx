# Composition

Composition in React involves building components by combining smaller, reusable components. The Composition Layout Pattern organizes these components into structured layouts, often using props like children to nest components flexibly within a parent container.

## Props drilling

Props drilling occurs when data is passed down through multiple layers of components via props, even if intermediate components don't use the data. This can make the code harder to maintain and less efficient. Solutions like Context API or state management libraries (e.g., Redux) are often used to avoid it.

# Composition Tips
now for example here we had global User but at this we only need the name the rest is we don't need and can modifiy the User type becuase 
it's work in mulitple time so we use Pick and only grap the name.
```tsx
import React from "react";

type User = {
  name: string;
  age: number;
  email: string;
  // ... other properties
};

const Footer = ({ user }: { user: Pick<User, "name"> }) => {
  return (
    <footer>
      <p>Welcome, {user.name}!</p>
      <p>&copy; 2023 Your Company. All rights reserved.</p>
    </footer>
  );
};

export default Footer;
```
also we can do this too, now we don't even need User type too also you can use React.Node
to give it mroe flexibly and add tag to it.
```tsx
import React from "react";

const Footer = ({ UserMessage }: { UserMessage: string }) => {
  return (
    <footer>
      <p>{UserMessage}</p>
      <p>&copy; 2023 Your Company. All rights reserved.</p>
    </footer>
  );
};

export default Footer;
```

`useRef` in React creates a mutable object (`{ current: value }`) that persists across re-renders. It's commonly used to access DOM elements directly (like focusing an input) or to store any mutable value without triggering re-renders. Unlike state, updating a ref doesnâ€™t cause the component to update.

Example:
```jsx
const inputRef = useRef(null);
// Later: <input ref={inputRef} />
// Access: inputRef.current.focus();
```