# When to Use `useReducer` Instead of `useState`?
- **Use `useReducer` when state logic is complex** (e.g., multiple sub-values, nested updates) or when the next state depends on the previous one.  
- **Better for large state objects** or when state transitions follow predictable patterns (like Redux).  
- **Easier to test and debug** since actions describe state changes clearly.  

### **Pros & Cons of `useReducer`**  
✅ **Pros:**  
- Handles complex state logic better.  
- Centralizes state updates via actions.  
- Improves performance for deep updates (avoids unnecessary re-renders).  

❌ **Cons:**  
- More boilerplate than `useState`.  
- Overkill for simple state management.  

### **Example: `useState` vs `useReducer`**  
#### **1. `useState` (Simple Counter)**  
```jsx
const [count, setCount] = useState(0);
const increment = () => setCount(count + 1);
```
#### **2. `useReducer` (Complex Counter with Actions)**  
```jsx
const initialState = { count: 0 };
const reducer = (state, action) => {
  switch (action.type) {
    case "INCREMENT": return { count: state.count + 1 };
    case "DECREMENT": return { count: state.count - 1 };
    default: return state;
  }
};
const [state, dispatch] = useReducer(reducer, initialState);
// Usage: dispatch({ type: "INCREMENT" });
```
**Use `useReducer` when managing structured state with multiple actions!** 🚀